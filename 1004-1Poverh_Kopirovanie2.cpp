/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   1004-1Poverh_Kopirovanie2.cpp                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: areggie <areggie@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/10/02 23:56:22 by areggie           #+#    #+#             */
/*   Updated: 2021/10/04 21:41:29 by areggie          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
https://ravesli.com/urok-145-poverhnostnoe-i-glubokoe-kopirovanie/
*/

/*
Урок №145. Поверхностное и глубокое копирование
*/

/*
Этот урок к 04day of cpp

Код поверхностного копирования
*/

#include <cstring> // для strlen()
#include <cassert> // для assert()
#include <iostream> 

// Здесь не прописаны конструкторы копирования и 
// не прописана перегрузка оператора присваивания
// Следовательно, язык C++ предоставит конструктор 
//копирования и оператор присваивания по умолчанию,
//которые будут выполнять поверхностное копирование.
 
class SomeString
{
private:
    char *m_data;
    int m_length;
 
public:
    SomeString(const char *source="")
    {
        assert(source); // обещаем что source  не является нулевой строкой
        // обещание будет проверено
 
        // Определяем длину source + еще один символ для нуль-терминатора (символ завершения строки)
        m_length = strlen(source) + 1;
        
        // Выделяем достаточно памяти для хранения копируемого значения в соответствии с длиной этого значения
        m_data = new char[m_length];
        
        // Копируем значение по символам в нашу выделенную память
        for (int i=0; i < m_length; ++i)
            m_data[i] = source[i];
    
        // Убеждаемся, что строка завершена
        m_data[m_length-1] = '\0';
    }
 
    ~SomeString() // деструктор
    {
        // Освобождаем память, выделенную для нашей строки
        delete[] m_data;
    }
 
    char* getString() { return m_data; }
    int getLength() { return m_length; }
};

int main()
{
    SomeString hello("Hello, world!");
    {
        SomeString copy = hello; // используется конструктор копирования по умолчанию
    } // объект copy является локальной переменной, которая уничтожается здесь. 
    //Деструктор удаляет значение-строку объекта copy, оставляя, 
    //таким образом, hello с висячим указателем
 
    std::cout << hello.getString() << '\n'; // здесь неопределенные результаты
    // hello и copy указывают на один массив, но соpу уничтожается вместо с массивом
    // hello указывает на стертый массив
 
    return 0;
}

/*
При компиляции будет вызываться деструктор для двух массивов
Один указатель был утерян при поверхностном копировании и создалась утечка
Деструктор вызвался для указателя на массив который был утерян так 
как указатель скопировал адрес другого указателя 

Детальное объяснение на сайте

Hello, world!
a.out(92045,0x1057a95c0) malloc: *** error for object 0x7f89a0c006a0: pointer being freed was not allocated
a.out(92045,0x1057a95c0) malloc: *** set a breakpoint in malloc_error_break to debug
[1]    92045 abort      ./a.out

ВЫВОД: Корнем этой проблемы является поверхностное копирование, 
выполняемое конструктором копирования по умолчанию.
Такое копирование почти всегда приводит к проблемам.

РЕШЕНИЕ: ВЫПОЛНЕНИЕ ГЛУБОКОГО КОПИРОВАНИЯ (см след файл)

В файле 0912-2KonstruktorKopirovan.cpp ссылка на видео - в ней рассказывается о подобной проблеме
см https://www.youtube.com/watch?v=3x9nd6Tm7Pc&t=803s (c 16 мин и дальше)
(с 23 мин поясняется как правильно сделать новый указатель на выделенный массив)
*/
