/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   0926VirtualMethods_Polymorphism.cpp                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: areggie <areggie@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/09/26 17:11:15 by areggie           #+#    #+#             */
/*   Updated: 2021/09/26 18:34:00 by areggie          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
https://www.youtube.com/watch?v=YlbFPAugFNA
// лекция на Simple Code 103
*/

/*
Виртуальные методы класса c++. 
Ключевое слово virtual. 
Ключевое слово override. 
ООП. C++ #103
*/

/*
Polymorphism
Virtual methods
virtual // в базовом классе пишем перед методом это слово: значит в наследуемых они будут
иметь свою реализацию хотя будут иметь такое же название
override
*/

/*
Виртуальные функции - это один из способов реализации полиморфизма
Другой способ - работа через указатель на функцию (см лекц 65) и
можно см 0911-5GoodExamplePtrToFunction.cpp
*/

// программа игрока который использует разное оружие для стрельбы

#include <iostream>

class Gun
{
public:
	virtual void Shoot() // 4 : 11 пишем слово virtual чтобы можно было бы использовать эту же функцию
	// но только с другой реализацией в наследуемом классе
	// теперь это виртуальные метод
	{
		std::cout << "Bang!" << std::endl;
	}
	
};

class SubMachineGun :public Gun // наследуем от класса Gun
{
public:
	void Shoot() //override // так как у нас в базовом классе эта функция виртуальная 
	// значит в наследуемом классе мы можем ее же вызвать но написать ей другую реализацию
	// слово OVERRIDE здесь является контроллером: оно контролирует чтобы была именно такая же функция:
	// подаваемое значение, название, возвращаемое значение
	// в C++ слово override не обязательно для написания (но лучше написать для контроля) см 6:44
	// Это слово +11 стандарта
	// Если подать инт в функцию то override выдаст ошибку на этапе компиляции, но если не писать 
	// override метод скомпилируется но как другая функция
	// если убрать слово virtual в методе базового класса то компилятор будет ругаться
	{
		std::cout << "Bang! Bang! Bang!" << std::endl;
	}
	
};

class Bazooka :public Gun // наследуем от класса Gun
{
public:
	void Shoot() //override // так как у нас в базовом классе эта функция виртуальная 
	// значит в наследуемом классе мы можем ее же вызвать но написать ей другую реализацию
	// слово OVERRIDE здесь является контроллером: оно контролирует чтобы была именно такая же функция:
	// подаваемое значение, название, возвращаемое значение
	// в C++ слово override не обязательно для написания (но лучше написать для контроля) см 6:44
	// Это слово +11 стандарта
	// Если подать инт в функцию то override выдаст ошибку на этапе компиляции, но если не писать 
	// override метод скомпилируется но как другая функция
	// если убрать слово virtual в методе базового класса то компилятор будет ругаться
	{
		std::cout << "BADABOOM!" << std::endl;
	}
};

class Player
{
	public:
		void Shoot(Gun *ptr) // так как он должен стрелять то передадим ему указатель на класс GUN
		{
			ptr->Shoot(); //через указатель обращаемся к методу
		}
};


int main()
{
	// Gun gun;
	// gun.Shoot();

	//Суть полиморфизма - мы можем создать указатель на объект базового или наследуемого класса и
	// через разыменование вызывать метод (см 10:11)
	// Gun gun;// создали объект класса gun
	// Gun *pointer_to_gun; // создали указатель этого же класса
	// pointer_to_gun = &gun; // указатель может указывать на объект этого же класса или на
	//объект класса-наследника:

	// Gun *pointer_to_gun; // создали указатель этого же класса
	// SubMachineGun machinegun; 
	// pointer_to_gun = &machinegun; //так как класс SubMachineGun это класс-наследник от 
	// // класса Gun то нащ указатель может работать с унаследованными объектами и их метолдвами
	// pointer_to_gun->Shoot(); // здесь стрелять будет пулемёт (см 12:10)

	// Gun gun;
	// Gun *pointer_to_gun; // создали указатель этого же класса
	// SubMachineGun machinegun; 
	// pointer_to_gun = &gun; //указатель теперь ссылается на объект базового класса
	// pointer_to_gun->Shoot(); // здесь стрелять теперь будет пистолет (см 12:39)

	// Обращаясь через указатель на объекты базового и наследуемых классов можно сократить код 
	// и работать с разной реализацией методов наследумых классов

	//ключевой момент полиморфизма:
	// можно передавать по указателю оружие для стрельбы любого наследуемого класса

	Gun gun;
	SubMachineGun machinegun;
	Bazooka bazooka;
	
	Player player;
	// player.Shoot(&gun); //передали указатель на объект класса Gun (тогда стрелять будет как пистолет)
	// player.Shoot(&machinegun); //передали указатель на объект унаследованного класса SubMAchineGun (тогда стрелять будет очередью)
	player.Shoot(&bazooka); //передали указатель на объект унаследованного класса Bazooka (тогда стрелять будет c большим звково)
	
	return 0;
}