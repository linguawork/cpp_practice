/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   1004-0AssertFunctionDebug.cpp                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: areggie <areggie@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/10/04 19:12:31 by areggie           #+#    #+#             */
/*   Updated: 2021/10/04 19:27:40 by areggie          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
Источник:
http://ci-plus-plus-snachala.ru/?p=4
пообщать и выполнить // или не выполнить
*/

/*
чтобы программист мог немного обезопасить себя от собственной погрешности,
существует специальный макрос assert, 
действие которого такое же, как у if, но синтаксис немного другой.

Чтобы использовать assert, необходимо подключить заголовочный файл cassert или assert.h,
если компилятор древний.

assert можно отключить при окончательной сборке программы 
с помощью отключающего этот макрос макроса NDEBUG.

*/

/*
В близкой к реальной ситуации может быть пример проверки невыхода 
за границы массива. "Поскольку я упрощаю примеры, то реальный и не показываю,
моделирую просто чем-то отдалённо напоминающий пример из реальных программ.
Учитывайте это."
Ниже пример из источника:
Первая часть работает без контроля assert
Вторая часть работает с assert
Раскомментить/закомментить нужное
*/

/* Первая часть: *************************** */

// #include <iostream>
// #include <assert.h>     /* assert */
 
// using std::ifstream;
// using std::cout;
 
 
// /*Упрощённая структура имитирует класс-массив*/
// struct MyArr
// {
//     static const int size = 50;//фиксированное число элементов в массиве
//     int arr[size];
 
// 	/*Функция для вывода элемента по индексу*/
//     int print(int i)
// 	{
//        return  arr[i];//Возвращаем вытаскиваемое из массива значение
//     };
 
 
// 	/*Функция заполняет массив значениями, чтобы сейчас не было пустышки*/
//     void fill()
// 	{
//         for (int i = 0; i < size; i++)
// 		{
//             arr[i] = i+1;
//         }
//     }
// };
 
// int main ()
// {
//    MyArr ma;//Объект нашей структуры
//    ma.fill();//Заполняем значениями
 
//    for (int i=0; i<100; i++)
//    {  //В массиве внутри структуры только 50 элементов, мы выходим за границу
//     cout << ma.print(i) << '\n';//Выводим на экран данные
//    }
// }

/* ***************************************************** */
//Вторая часть: закомментить первую часть чтобы сработала вторая

#include <iostream>
#include <assert.h>     /* assert */
 
using std::ifstream;
using std::cout;
 
 
/*Упрощённая структура имитирует класс-массив*/
struct MyArr
{
    static const int size = 50;
    int arr[size];
 
/*Функция для вывода элемента по индексу*/
    int print(int i)
	{
    	assert(i < size);   //Добавили обещание, что i не окажется больше, чем size
    	return  arr[i];      //Возвращаем вытаскиваемое из массива значение
    };
 
    void fill()
	{
        for (int i=0; i<size; i++)
		{
            arr[i] = i+1;
        }
    }
};
 
int main ()
{
   MyArr ma;
   ma.fill();
 
   for (int i=0; i<100; i++)
   {
		cout << ma.print(i) << '\n';
   }
}