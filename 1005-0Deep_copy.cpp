/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   1005-0Deep_copy.cpp                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: areggie <areggie@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/10/05 22:34:35 by areggie           #+#    #+#             */
/*   Updated: 2021/10/05 22:49:37 by areggie          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
https://ravesli.com/urok-145-poverhnostnoe-i-glubokoe-kopirovanie/
*/

/*
Урок №145. Поверхностное и глубокое копирование
*/

/*
Этот урок к 04day of cpp, ex01

Код глубокого копирования
Одним из решений этой проблемы является выполнение глубокого копирования. 
При глубоком копировании память сначала выделяется для копирования адреса, 
который содержит исходный указатель, а затем для копирования фактического значения. 
Таким образом копия находится в отдельной, от исходного значения, 
памяти и они никак не влияют друг на друга.
 Для выполнения глубокого копирования нам 
 необходимо написать свой собственный конструктор копирования 
 и перегрузку оператора присваивания.


*/


// КОНСТРУКТОР КОПИРОВАНИЯ
SomeString::SomeString(const SomeString& source)
{
	// Поскольку m_length не является указателем, то мы можем выполнить поверхностное копирование
	m_length = source.m_length;

	// m_data является указателем, поэтому нам нужно выполнить глубокое копирование, при условии,
	// что этот указатель не является нулевым
	if (source.m_data) // проверка на ненулевое значение
	{
		//Если имеет ненулевое значение, то выделяем память для нашей копии под длину копируемого объекта
		m_data = new char[m_length];

		// Выполняем копирование по ячейкам в массиве
		for (int i=0; i < m_length; ++i)
			m_data[i] = source.m_data[i];
	}
	else
		m_data = 0;
}


// ОПЕРАТОР ПРИСВАИВАНИЯ (здесь очищаем и выделяем снова память под массив чтобы был другой указатель)
SomeString& SomeString::operator=(const SomeString & source)
{
    // Проверка на самоприсваивание
    if (this == &source)
        return *this;
 
    // Сначала нам нужно очистить предыдущее значение m_data (члена неявного объекта)
    delete[] m_data;
 
    // Поскольку m_length не является указателем, то мы можем выполнить поверхностное копирование
    m_length = source.m_length;
 
    // m_data является указателем, поэтому нам нужно выполнить глубокое копирование, при условии, что этот указатель не является нулевым
    if (source.m_data)
    {
        // Выделяем память для нашей копии
        m_data = new char[m_length];
 
        // Выполняем копирование
        for (int i=0; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = 0;
 
    return *this;
}

/*
ВЫВОД:

   Конструктор копирования и оператор присваивания, 
   предоставляемые по умолчанию языком C++, 
   выполняют поверхностное копирование, 
   что отлично подходит для классов без динамически выделенных членов.

   Классы с динамически выделенными членами должны иметь конструктор копирования 
   и перегрузку оператора присваивания, которые выполняют глубокое копирование.
   
*/



