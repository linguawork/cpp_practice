/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   D03Ex01_220501ModificatorDostupaNasledovani        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: areggie <areggie@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/09/26 15:53:17 by areggie           #+#    #+#             */
/*   Updated: 2022/05/01 17:30:47 by areggie          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
Источник кода: https://www.youtube.com/watch?v=6udKffus77A

Модификаторы доступа при наследовании. 
private public protected Спецификаторы доступа. 
ООП. C++ #99


На видео на 7:47 Сергей приводит таблицу модификаторов доступа при наследовании
Очень хорошая таблица

Ниже прописан его код для понимания изменений видимости полей при том или
ином модификаторе наслелодования

Таблицу отдельно скопировал и сохранил в этой же папке
Таблица его не совсем верная так как private модификатор ведет себя также как protected


В основном при наследовании используется модификатор public

При наследовании можно пользоваться методами родителя



*/

#include <iostream>

using namespace std;

class A
{
	private:
		string msgOne = "Сообщение один";	
	
	protected: // как приватные но видимы для наследников
		string msgTwo = "Сообщение два";	

	public:
		string msgThree = "Сообщение три";	
	
};

// class B : public A 
/*
модификатор public никак не изменяет
доступность полей родительского класса 

private поле родителя недоступно в наследнике и в main // KO - наслед, KO - main
protected поле родителя доступно для наследников, Но не в main // OK - наслед, KO - main
public поле родителя доступно и для наследника и для main // OK - наслед, OK - main
*/


// class B : private A 
/* 
модификатор private устанавливает доступность
всех полей род. класса на уровень private

private поле родителя недоступно и в наследнике, и в main  // KO - наслед, KO - main
protected поле родителя доступно для наследников, Но не в main // OK - наслед, KO - main
public поле родителя доступно и для наследника, Но не в main // OK - наслед, KO - main ===> public становится protected


*/


class B : protected A 
/* 
модификатор protected устанавливает доступность
всех полей род. класса на уровень 

private поле родителя недоступно и в наследнике, и в main  // KO - наслед, KO - main
protected поле родителя доступно для наследников, Но не в main // OK - наслед, KO - main
public поле родителя доступно и для наследника, Но не в main // OK - наслед, KO - main ===> public становится protected


*/

{
	public:
		void PrintMsg()
		{
			cout << msgThree << endl;
		}
	
	
};


//======================= Поведение еще одного подкласса нужно проверять
class C : public B 
/* 
Модификатор класса B установлен как protected
модификатор класса С установлен как public

C ведет себя как protected (я думаю он дублирует)

private поле родителя недоступно и в наследнике, и в main  // KO - наслед, KO - main
protected поле родителя доступно для наследников, Но не в main // OK - наслед, KO - main
public поле родителя доступно и для наследника, Но не в main // OK - наслед, KO - main ===> public становится protected


*/

{
	public:
		void PrintMsg()
		{
			cout << msgOne << endl;
		}
	
	
};




int main()
{

	B b;
	C c;

	c.msgOne;

	


return 0;	
}

